<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Interactive Brain</title>
<style>
    /* Basic styling for the page */
    body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        font-family: 'Inter', sans-serif;
    }
    /* Style for the canvas element */
    canvas {
        display: block;
        cursor: pointer;
        background-color: #000;
    }
    /* A simple modal for notifications instead of alert() */
    .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
        justify-content: center;
        align-items: center;
    }
    .modal-content {
        background-color: #1a1a1a;
        color: #f1f1f1;
        padding: 20px 30px;
        border: 1px solid #888;
        border-radius: 12px;
        text-align: center;
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        font-size: 1.1em;
    }
</style>
<!-- Google Fonts import for Inter -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">
</head>
<body>

<canvas id="brainCanvas"></canvas>

<div id="navigationModal" class="modal">
    <div class="modal-content">
        <p id="modalText"></p>
    </div>
</div>

<script>
    const canvas = document.getElementById('brainCanvas');
    const ctx = canvas.getContext('2d');
    const modal = document.getElementById('navigationModal');
    const modalText = document.getElementById('modalText');

    // --- Canvas and Shape Sizing ---
    // Make the canvas responsive to the window size
    canvas.height = window.innerHeight * 0.85;
    canvas.width = canvas.height;

    // canvas.width = window.innerWidth > 800 ? 800 : window.innerWidth * 0.95;
    // canvas.height = window.innerHeight > 600 ? 600 : window.innerHeight * 0.95;

    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const verticalMargin = canvas.height * 0.025; // 2.5% margin top and bottom
    const hemisphereRadiusX = canvas.width * 0.22;
    const hemisphereRadiusY = (canvas.height / 2) - verticalMargin + canvas.height * 0.12; // Make hemispheres taller

    // --- State Variables ---
    let mouseX = -1; // Use -1 to indicate the mouse is outside the canvas
    let mouseY = -1;
    const neuronCount = 800; // Doubled for a denser look
    const leftNeurons = [];
    const rightNeurons = [];

    // --- Colors ---
    const baseColorLeft = 'rgba(0, 150, 255, 0.6)';
    const hoverColorLeft = 'rgba(120, 210, 255, 1)';
    const baseColorRight = 'rgba(255, 100, 0, 0.6)';
    const hoverColorRight = 'rgba(255, 165, 50, 1)';
    const connectorColorLeft = 'rgba(0, 150, 255, 0.15)';
    const connectorColorRight = 'rgba(255, 100, 0, 0.15)';

    /**
     * Represents a single neuron (a dot).
     * It handles its own position, velocity, and drawing logic.
     */
    class Neuron {
        constructor(x, y) {
            this.originX = x;
            this.originY = y;
            this.x = x;
            this.y = y;
            // Increased radius for slightly bigger neurons
            this.radius = Math.random() * 2.2 + 1.5;
            // Velocity for the animation
            this.vx = (Math.random() - 0.5) * 0.2;
            this.vy = (Math.random() - 0.5) * 0.2;
            // Max distance it can travel from its origin
            this.maxDist = Math.random() * 8 + 4;
        }

        /**
         * Updates the neuron's position for the animation effect.
         */
        update() {
            this.x += this.vx;
            this.y += this.vy;

            const dist = Math.hypot(this.x - this.originX, this.y - this.originY);
            // Reverse direction if it moves too far from its origin
            if (dist > this.maxDist) {
                this.vx *= -1;
                this.vy *= -1;
            }
        }

        /**
         * Draws the neuron on the canvas with a given color.
         * @param {string} color - The fill color for the neuron.
         */
        draw(color) {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
        }
    }

    /**
     * Creates an array of neurons within a semi-elliptical shape to form a brain hemisphere.
     * @param {number} count - The number of neurons to create.
     * @param {string} side - 'left' or 'right', determines the position.
     * @returns {Neuron[]} An array of Neuron objects.
     */
    function createHemisphere(count, side) {
        const neurons = [];
        const sign = (side === 'left') ? -1 : 1;
        const wideningFactor = 2.0; // Increase for more width on the outside

        for (let i = 0; i < count; i++) {
            // Use polar coordinates to distribute points within a semi-ellipse
            const angle = (Math.random() * Math.PI) - (Math.PI / 2); // Angle from -90 to +90 degrees
            const radiusScalar = Math.sqrt(Math.random()); // Use sqrt for a more even distribution

            // Egg shape: scale horizontal radius based on vertical position
            // At the top (angle ~ -PI/2), factor is 0.8; at bottom (angle ~ PI/2), factor is 1.15
            const verticalFactor = 0.8 + 0.35 * ((Math.sin(angle) + 1) / 2); // Range: 0.8 to 1.15

            let localRadiusX = hemisphereRadiusX * verticalFactor;
            if (side === 'left' && Math.cos(angle) > 0) {
                localRadiusX = hemisphereRadiusX * wideningFactor * verticalFactor;
            } else if (side === 'right' && Math.cos(angle) > 0) {
                localRadiusX = hemisphereRadiusX * wideningFactor * verticalFactor;
            }

            // Calculate x and y to fill the entire semi-ellipse shape.
            const x = centerX + sign * (Math.cos(angle) * localRadiusX * radiusScalar);
            const y = centerY + Math.sin(angle) * hemisphereRadiusY * radiusScalar;
            
            neurons.push(new Neuron(x, y));
        }
        return neurons;
    }

    /**
     * Draws connector lines between neurons that are close to each other.
     * @param {Neuron[]} neurons - The array of neurons to connect.
     * @param {string} color - The color of the connector lines.
     */
    function drawConnectors(neurons, color) {
        ctx.strokeStyle = color;
        ctx.lineWidth = 0.4;
        for (let i = 0; i < neurons.length; i++) {
            for (let j = i + 1; j < neurons.length; j++) {
                const distance = Math.hypot(neurons[i].x - neurons[j].x, neurons[i].y - neurons[j].y);

                // Connect if they are close enough, creating the web effect
                if (distance < 55) {
                    ctx.beginPath();
                    ctx.moveTo(neurons[i].x, neurons[i].y);
                    ctx.lineTo(neurons[j].x, neurons[j].y);
                    ctx.stroke();
                }
            }
        }
    }

    /**
     * The main animation loop, called for every frame.
     */
    function animate() {
        // Clear the canvas for the next frame
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Check if the mouse is hovering over the left or right half
        const isHoveringLeft = mouseX > 0 && mouseX < centerX;
        const isHoveringRight = mouseX >= centerX && mouseX < canvas.width;

        // Determine colors based on hover state
        const currentLeftColor = isHoveringLeft ? hoverColorLeft : baseColorLeft;
        const currentRightColor = isHoveringRight ? hoverColorRight : baseColorRight;
        
        // --- Draw all components ---
        drawConnectors(leftNeurons, connectorColorLeft);
        drawConnectors(rightNeurons, connectorColorRight);

        leftNeurons.forEach(neuron => {
            neuron.update();
            neuron.draw(currentLeftColor);
        });

        rightNeurons.forEach(neuron => {
            neuron.update();
            neuron.draw(currentRightColor);
        });

        // Request the next frame
        requestAnimationFrame(animate);
    }

    /**
     * Shows a custom message instead of a browser alert.
     * @param {string} message - The text to display.
     */
    function showModal(message) {
        modalText.textContent = message;
        modal.style.display = 'flex';
        setTimeout(() => {
            modal.style.display = 'none';
        }, 1500); // Hide after 1.5 seconds
    }

    // --- Event Listeners ---

    // Track mouse movement over the canvas
    canvas.addEventListener('mousemove', (event) => {
        const rect = canvas.getBoundingClientRect();
        mouseX = event.clientX - rect.left;
        mouseY = event.clientY - rect.top;
    });

    // Reset mouse position when it leaves the canvas to stop the hover effect
    canvas.addEventListener('mouseleave', () => {
        mouseX = -1;
        mouseY = -1;
    });

    // Handle clicks for navigation
    canvas.addEventListener('click', (event) => {
        const rect = canvas.getBoundingClientRect();
        const clickX = event.clientX - rect.left;

        if (clickX < centerX) {
            showModal("Navigating to 'filtered_code.html'...");
            // In a real application, you would use:
            // window.location.href = 'filtered_code.html';
        } else {
            showModal("Navigating to 'filtered_art.html'...");
            // In a real application, you would use:
            // window.location.href = 'filtered_art.html';
        }
    });
    
    // Handle window resizing
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth > 800 ? 800 : window.innerWidth * 0.95;
        canvas.height = window.innerHeight > 600 ? 600 : window.innerHeight * 0.95;
        // This is a simplified resize handler. For a more robust solution,
        // you would need to regenerate the neuron positions based on the new size.
    });


    // --- Initialization ---
    // Create the neurons for both hemispheres and start the animation
    leftNeurons.push(...createHemisphere(neuronCount, 'left'));
    rightNeurons.push(...createHemisphere(neuronCount, 'right'));
    animate();

</script>
</body>
</html>
